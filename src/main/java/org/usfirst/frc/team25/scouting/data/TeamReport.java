package org.usfirst.frc.team25.scouting.data;

import org.usfirst.frc.team25.scouting.data.models.Autonomous;
import org.usfirst.frc.team25.scouting.data.models.ScoutEntry;
import org.usfirst.frc.team25.scouting.data.models.TeleOp;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;


/**
 * Object model containing individual reports of teams in events and methods to process data
 */
public class TeamReport {

    private final transient ArrayList<ScoutEntry> entries;
    private final int teamNum;

    public static final String[] autoMetricNames = new String[]{"cargoShipHatches", "rocketHatches", "cargoShipCargo",
            "rocketCargo"};
    public static final String[] teleMetricNames = new String[]{"cargoShipHatches", "rocketLevelOneHatches",
            "rocketLevelTwoHatches", "rocketLevelThreeHatches", "cargoShipCargo", "rocketLevelOneCargo",
            "rocketLevelTwoCargo", "rocketLevelThreeCargo"};
    public static String[] levelPrefixes = new String[]{"levelOne", "levelTwo", "levelThree", "total"};
    public static final String[] overallMetricNames = new String[]{"calculatedPointContribution",
            "calculatedSandstormPoints",
            "calculatedTeleOpPoints"};
    private String teamName, frequentRobotCommentStr, allComments;
    private HashMap<String, Double> averages, standardDeviations, attemptSuccessRates;
    private HashMap<String, Integer> counts;


    public TeamReport(int teamNum) {
        this.teamNum = teamNum;
        entries = new ArrayList<>();
        teamName = "";
        frequentRobotCommentStr = "";

        averages = new HashMap<>();
        standardDeviations = new HashMap<>();
        counts = new HashMap<>();
        attemptSuccessRates = new HashMap<>();

    }

    /**
     * Generates an easily-readable report with relevant stats on an team's capability
     *
     * @return A formatted string with relevant aggregate team stats
     */
    public String getQuickStatus() {

        String statusString = "Team " + getTeamNum();

        if (!getTeamName().isEmpty()) {
            statusString += " - " + getTeamName();
        }

        statusString += "\n\nSandstorm:";

        for (String metric : autoMetricNames) {
            statusString += "\nAvg. " + StringProcessing.convertCamelToSentenceCase(metric) + ": " + Stats.round
                    (averages.get("auto" + metric), 2);
        }

        statusString += "\nHAB line cross: " + Stats.round(attemptSuccessRates.get("totalCross") * 100, 2) + "% ("
                + counts.get("totalCross") + "/" + entries.size() + ")";

        for (int i = 0; i < 2; i++) {
            statusString += "\nHAB lvl " + (i + 1) + " cross: ";
            statusString += Stats.round(attemptSuccessRates.get(levelPrefixes[i] + "Cross") * 100, 2) + "% " +
                    "(" + counts.get(levelPrefixes[i] + "Cross") + "/" + counts.get(levelPrefixes[i] + "Start") + ")";
        }

        statusString += "\n\nTele-Op:";

        for (String metric : teleMetricNames) {
            statusString += "\nAvg. " + StringProcessing.convertCamelToSentenceCase(metric) + ": " + Stats.round
                    (averages.get("tele" + metric), 2);
        }

        statusString += "\n\nEndgame:";

        for (int i = 0; i < 4; i++) {

            if (i == 3) {
                statusString += "\nTotal climb success: ";
            } else {
                statusString += "\nLvl " + (i + 1) + " climb success: ";
            }
            statusString += Stats.round(attemptSuccessRates.get(levelPrefixes[i] + "Climb") * 100, 0) + "% " +
                    "(" + counts.get(levelPrefixes[i] + "ClimbSuccess") + "/" + counts.get(levelPrefixes[i] +
                    "ClimbAttempt") + ")";

        }

        statusString += "\n\nOverall:";

        for (String metric : overallMetricNames) {
            statusString += "\nAvg. " + StringProcessing.convertCamelToSentenceCase(metric) + ": " + Stats.round
                    (averages.get(metric), 2);
        }


        statusString += "\n\nCommon quick comments:\n" + frequentRobotCommentStr;


        return statusString;

    }

    public String getTeamName() {
        return teamName;
    }

    /**
     * Method to fetch the nickname of a team from a file
     *
     * @param dataLocation location of the TeamNameList file generated by <code>exportTeamList</code>
     */
    public void autoGetTeamName(File dataLocation) {
        String data = FileManager.getFileString(dataLocation);
        String[] values = data.split(",\n");

        for (String value : values) {

            if (value.split(",")[0].equals(Integer.toString(teamNum))) {

                teamName = value.split(",")[1];
                return;
            }
        }
    }

    public void findFrequentComments() {

        HashMap<String, Integer> commentFrequencies = new HashMap<>();
        if (entries.size() > 0) {
            for (String key : entries.get(0).getPostMatch().getRobotQuickCommentSelections().keySet()) {
                commentFrequencies.put(key, 0);
                for (ScoutEntry entry : entries) {
                    if (entry.getPostMatch().getRobotQuickCommentSelections().get(key)) {
                        commentFrequencies.put(key, 1 + commentFrequencies.get(key));
                    }
                }
            }
        }

        ArrayList<String> frequentRobotComment = new ArrayList<>();

        for (String key : commentFrequencies.keySet()) {

            // Feel free to change this ratio
            if (commentFrequencies.get(key) >= entries.size() / 4.0) {
                frequentRobotComment.add(key);
            }
        }

        for (String comment : frequentRobotComment) {

            frequentRobotCommentStr += StringProcessing.removeCommasBreaks(comment) + " \n";
        }

        allComments = "";
        for (ScoutEntry entry : entries) {
            if (!entry.getPostMatch().getRobotComment().equals("")) {
                allComments += entry.getPostMatch().getRobotComment() + "; ";
            }

        }

    }

    public void addEntry(ScoutEntry entry) {
        entry.getPostMatch().setRobotComment(StringProcessing.removeCommasBreaks(entry.getPostMatch().getRobotComment
                ()));

        entries.add(entry);
    }

    public ArrayList<ScoutEntry> getEntries() {
        return this.entries;
    }


    public int getTeamNum() {
        return teamNum;
    }

    public void calculateStats() {

        calculateCounts();
        calculateAverages();
        calculateStandardDeviations();
        calculateAttemptSuccessRates();

    }

    private void calculateAttemptSuccessRates() {

        for (int i = 0; i < 4; i++) {
            if (i != 2) {
                double crossRate = 0.0;

                if (i == 3 && entries.size() != 0) {
                    crossRate = (double) counts.get(levelPrefixes[i] + "Cross") / entries.size();
                } else if (counts.get(levelPrefixes[i] + "Start") != 0) {
                    crossRate = (double) counts.get(levelPrefixes[i] + "Cross") / counts.get(levelPrefixes[i] +
                            "Start");
                }

                attemptSuccessRates.put(levelPrefixes[i] + "Cross", crossRate);
            }

            double climbRate = 0.0;

            if (counts.get(levelPrefixes[i] + "ClimbAttempt") != 0) {
                climbRate = (double) counts.get(levelPrefixes[i] + "ClimbSuccess") / counts.get(levelPrefixes[i] +
                        "ClimbAttempt");
            }

            attemptSuccessRates.put(levelPrefixes[i] + "Climb", climbRate);
        }

        for (String prefix : new String[]{"cargo", "hatch"}) {

            double placeRate = 0.0;

            if (counts.get(prefix + "Start") != 0) {
                placeRate = (double) counts.get(prefix + "AutoSuccess") / counts.get(prefix + "Start");
            }

            attemptSuccessRates.put(prefix + "AutoSuccess", placeRate);
        }
    }

    private void calculateCounts() {
        final String[] levelMetricSuffixes = new String[]{"Start", "Cross", "ClimbAttempt", "ClimbSuccess"};

        for (String prefix : levelPrefixes) {
            for (String suffix : levelMetricSuffixes) {
                counts.put(prefix + suffix, 0);
            }
        }

        for (String prefix : new String[]{"cargo", "hatch"}) {
            for (String suffix : new String[]{"Start", "AutoSuccess"}) {
                counts.put(prefix + suffix, 0);
            }
        }

        for (ScoutEntry entry : entries) {

            incrementCount(levelPrefixes[entry.getPreMatch().getStartingLevel() - 1] + "Start");

            if (entry.getPreMatch().getStartingGamePiece().equals("Cargo")) {
                incrementCount("cargoStart");
            }

            if (entry.getPreMatch().getStartingGamePiece().equals("Hatch panel")) {
                incrementCount("hatchStart");
            }

            if (entry.getSandstormHatches() >= 1) {
                incrementCount("hatchAutoSuccess");
            }

            if (entry.getSandstormCargo() >= 1) {
                incrementCount("cargoAutoSuccess");
            }

            if (entry.getAutonomous().isCrossHabLine()) {
                incrementCount(levelPrefixes[entry.getPreMatch().getStartingLevel() - 1] + "Cross");
                incrementCount("totalCross");
            }

            if (entry.getTeleOp().isAttemptHabClimb()) {
                incrementCount(levelPrefixes[entry.getTeleOp().getAttemptHabClimbLevel() - 1] +
                        "ClimbAttempt");

                incrementCount("totalClimbAttempt");
            }

            if (entry.getTeleOp().isSuccessHabClimb()) {
                incrementCount(levelPrefixes[entry.getTeleOp().getSuccessHabClimbLevel() - 1] +
                        "ClimbSuccess");

                if (entry.getTeleOp().getSuccessHabClimbLevel() != entry.getTeleOp().getAttemptHabClimbLevel()) {
                    incrementCount(levelPrefixes[entry.getTeleOp().getSuccessHabClimbLevel() - 1] +
                            "ClimbAttempt");
                }

                incrementCount("totalClimbSuccess");
            }


        }
    }

    private void calculateAverages() {
        ArrayList<Object> autoList = SortersFilters.filterDataObject(entries, Autonomous.class);
        ArrayList<Object> teleList = SortersFilters.filterDataObject(entries, TeleOp.class);
        ArrayList<Object> overallList = new ArrayList<>(entries);

        for (String metric : autoMetricNames) {
            double[] values = Stats.getDoubleArray(autoList, metric, int.class);
            averages.put("auto" + metric, Stats.average(values));
        }
        for (String metric : teleMetricNames) {
            double[] values = Stats.getDoubleArray(teleList, metric, int.class);
            averages.put("tele" + metric, Stats.average(values));
        }
        for (String metric : overallMetricNames) {
            double[] values = Stats.getDoubleArray(overallList, metric, int.class);
            averages.put(metric, Stats.average(values));
        }
    }

    private void calculateStandardDeviations() {
        ArrayList<Object> autoList = SortersFilters.filterDataObject(entries, Autonomous.class);
        ArrayList<Object> teleList = SortersFilters.filterDataObject(entries, TeleOp.class);
        ArrayList<Object> overallList = new ArrayList<>(entries);

        for (String metric : autoMetricNames) {
            double[] values = Stats.getDoubleArray(autoList, metric, int.class);
            standardDeviations.put("auto" + metric, Stats.standardDeviation(values));
        }
        for (String metric : teleMetricNames) {
            double[] values = Stats.getDoubleArray(teleList, metric, int.class);
            standardDeviations.put("tele" + metric, Stats.standardDeviation(values));
        }
        for (String metric : overallMetricNames) {
            double[] values = Stats.getDoubleArray(overallList, metric, int.class);
            standardDeviations.put(metric, Stats.standardDeviation(values));
        }
    }

    private void incrementCount(String metricName) {
        if (counts.containsKey(metricName)) {
            counts.put(metricName, counts.get(metricName) + 1);
        } else {
            counts.put(metricName, 1);
        }
    }

    public void filterNoShow() {
        counts.put("noShow", 0);
        for (int i = 0; i < entries.size(); i++) {
            if (entries.get(i).getPreMatch().isRobotNoShow()) {
                entries.remove(i);
                i--;
                incrementCount("noShow");
            }
        }
    }

    public HashMap<String, Double> getAverages() {
        return averages;
    }

    public HashMap<String, Double> getStandardDeviations() {
        return standardDeviations;
    }

    public HashMap<String, Integer> getCounts() {
        return counts;
    }
}
